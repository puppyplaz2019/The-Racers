<!DOCTYPE html>
<html>
<head>
    <title>3D Estate V52 - Stable Build</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; pointer-events: none; border: 1px solid white; }
        #interaction { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: cyan; font-family: sans-serif; font-weight: bold; text-shadow: 2px 2px 0 #000; display: none; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h2>ESTATE V52</h2>
        <p><b>WASD</b> Move | <b>SPACE</b> Jump/Fly</p>
        <p><b>E</b> Drive Car | <b>B</b> Build Mode</p>
        <p><b>P</b> Pause</p>
        <p id="debug">Status: Running</p>
    </div>
    <div id="interaction">PRESS 'E' TO INTERACT</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let car, sunLight, sunMesh;
        let keys = {};
        let walls = []; 
        let interactables = [];
        let particles = [];
        
        // State
        let isDriving = false;
        let isFlying = false;
        let isPaused = false;
        let buildMode = false;
        let vy = 0; // Vertical velocity
        let dayTime = 0.5; // Start at Noon
        let weather = "clear";
        let rainSystem;

        // Materials
        const mats = {
            grass: new THREE.MeshStandardMaterial({ color: 0x2d5a27 }),
            sand: new THREE.MeshStandardMaterial({ color: 0xe6c288 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x5d3a1a }),
            leaf: new THREE.MeshStandardMaterial({ color: 0x1a4a15 }),
            water: new THREE.MeshStandardMaterial({ color: 0x00ccff, transparent: true, opacity: 0.7 }),
            brick: new THREE.MeshStandardMaterial({ color: 0xcc5522 }),
            car: new THREE.MeshStandardMaterial({ color: 0xff0000 }),
            road: new THREE.MeshStandardMaterial({ color: 0x333333 })
        };

        // --- INIT ---
        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 800);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
            // SAFETY: Start high up looking down
            camera.position.set(0, 30, 50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 2. Lighting
            const ambient = new THREE.AmbientLight(0x888888); // Bright ambient
            scene.add(ambient);

            sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -200; sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200; sunLight.shadow.camera.bottom = -200;
            scene.add(sunLight);

            sunMesh = new THREE.Mesh(new THREE.SphereGeometry(20), new THREE.MeshBasicMaterial({color: 0xffff00}));
            scene.add(sunMesh);

            // 3. Ground (Forest & Desert)
            const grass = new THREE.Mesh(new THREE.PlaneGeometry(1000, 2000), mats.grass);
            grass.rotation.x = -Math.PI/2; 
            grass.position.set(-500, -0.1, 0); 
            grass.receiveShadow = true;
            scene.add(grass);

            const sand = new THREE.Mesh(new THREE.PlaneGeometry(1000, 2000), mats.sand);
            sand.rotation.x = -Math.PI/2; 
            sand.position.set(500, 0, 0); 
            sand.receiveShadow = true;
            scene.add(sand);

            // 4. Content
            createVillage();
            createForest();
            createDesert();
            createCar();
            createPond();
            createNPCs();

            // 5. Input
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if(e.code === 'KeyP') isPaused = !isPaused;
                if(e.code === 'KeyE') handleInteract();
                if(e.code === 'KeyB') {
                    buildMode = !buildMode;
                    document.getElementById('debug').innerText = buildMode ? "Mode: BUILDING" : "Mode: WALKING";
                }
                if(e.code === 'Space' && !isDriving) {
                    if(keys['ShiftLeft']) { isFlying = !isFlying; vy = 0; } // Shift+Space to toggle fly
                    else if(!isFlying && camera.position.y <= 3) { vy = 0.5; } // Jump
                }
            });
            document.addEventListener('keyup', (e) => keys[e.code] = false);
            document.addEventListener('mousedown', handleClick);

            // Start Loop
            animate();
        }

        // --- CONTENT CREATION ---
        function createVillage() {
            // Simple House Function
            function makeHouse(x, z) {
                const house = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(15, 10, 15), mats.brick);
                body.position.y = 5; body.castShadow = true;
                const roof = new THREE.Mesh(new THREE.ConeGeometry(12, 6, 4), mats.wood);
                roof.position.y = 13; roof.rotation.y = Math.PI/4;
                
                // Interior items (visible through walls glitch technically, but simple for now)
                const table = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 4), mats.wood);
                table.position.set(0, 1, 0);
                
                house.add(body, roof, table);
                house.position.set(x, 0, z);
                scene.add(house);
                walls.push(new THREE.Box3().setFromObject(body));
            }
            makeHouse(-40, -40);
            makeHouse(-80, -10);
            makeHouse(-40, 30);
        }

        function createForest() {
            for(let i=0; i<50; i++) {
                const x = Math.random() * -400 - 50;
                const z = Math.random() * 600 - 300;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 5), mats.wood);
                trunk.position.y = 2.5;
                const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(4), mats.leaf);
                leaves.position.y = 6;
                tree.add(trunk, leaves);
                tree.position.set(x, 0, z);
                scene.add(tree);
                walls.push(new THREE.Box3().setFromObject(trunk));
            }
        }

        function createDesert() {
            for(let i=0; i<30; i++) {
                const x = Math.random() * 400 + 50;
                const z = Math.random() * 600 - 300;
                const cactus = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 2), mats.leaf);
                cactus.position.set(x, 4, z);
                scene.add(cactus);
                walls.push(new THREE.Box3().setFromObject(cactus));
            }
        }

        function createCar() {
            car = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 7), mats.car);
            body.position.y = 1.5; body.castShadow = true;
            car.add(body);
            // Wheels
            const wGeo = new THREE.CylinderGeometry(0.6, 0.6, 1);
            const wMat = new THREE.MeshBasicMaterial({color:0x000000});
            [[-2, 2], [2, 2], [-2, -2], [2, -2]].forEach(pos => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI/2;
                w.position.set(pos[0], 0.6, pos[1]);
                car.add(w);
            });
            car.position.set(10, 0, 10);
            scene.add(car);
        }

        function createPond() {
            const pond = new THREE.Mesh(new THREE.CircleGeometry(20, 32), mats.water);
            pond.rotation.x = -Math.PI/2;
            pond.position.set(45, 0.1, -45);
            scene.add(pond);
            
            // Fountain particles
            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(300); // 100 particles * 3
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const part = new THREE.Points(geom, new THREE.PointsMaterial({color: 0xffffff, size: 0.5}));
            part.position.set(45, 0, -45);
            scene.add(part);
            particles.push({mesh: part, type: 'fountain'});
        }

        function createNPCs() {
            const npc = new THREE.Mesh(new THREE.CapsuleGeometry(1, 3, 4), new THREE.MeshStandardMaterial({color: 0x0000ff}));
            npc.position.set(-20, 1.5, -20);
            scene.add(npc);
            interactables.push({mesh: npc, msg: "Villager: Welcome to Estate V52!"});
            walls.push(new THREE.Box3().setFromObject(npc));
        }

        // --- GAME LOGIC ---

        function handleInteract() {
            if(isDriving) {
                isDriving = false;
                camera.position.y = 5; // Get out
                camera.position.x += 5;
                return;
            }
            if(camera.position.distanceTo(car.position) < 8) {
                isDriving = true;
                buildMode = false;
            }
        }

        function handleClick(e) {
            if(!buildMode || isPaused) return;
            // Build simple block in front of camera
            const box = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), mats.brick);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            box.position.copy(camera.position).add(dir.multiplyScalar(10));
            box.position.y = 1;
            scene.add(box);
            walls.push(new THREE.Box3().setFromObject(box));
        }

        function updateEnvironment() {
            // Day/Night
            dayTime += 0.0005;
            if(dayTime > 1) dayTime = 0;
            const r = 300;
            const ang = (dayTime - 0.5) * Math.PI * 2;
            sunMesh.position.set(Math.cos(ang)*r, Math.sin(ang)*r, 0);
            sunLight.position.copy(sunMesh.position);
            
            if(dayTime > 0.2 && dayTime < 0.8) {
                scene.background.setHex(0x87CEEB); 
                scene.fog.color.setHex(0x87CEEB);
            } else {
                scene.background.setHex(0x111122);
                scene.fog.color.setHex(0x111122);
            }

            // Fountain Animation
            particles.forEach(p => {
                if(p.type === 'fountain') {
                    const pos = p.mesh.geometry.attributes.position.array;
                    for(let i=0; i<pos.length; i+=3) {
                        if(pos[i+1] <= 0) {
                            pos[i] = (Math.random()-0.5)*2;
                            pos[i+1] = Math.random()*8; // Reset height
                            pos[i+2] = (Math.random()-0.5)*2;
                        }
                        pos[i+1] -= 0.1; // Gravity
                    }
                    p.mesh.geometry.attributes.position.needsUpdate = true;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if(isPaused) return;

            updateEnvironment();

            // Interactions
            let nearInt = false;
            interactables.forEach(i => {
                if(camera.position.distanceTo(i.mesh.position) < 5) {
                    document.getElementById('interaction').style.display = 'block';
                    document.getElementById('interaction').innerText = i.msg;
                    nearInt = true;
                }
            });
            if(camera.position.distanceTo(car.position) < 8 && !isDriving) {
                document.getElementById('interaction').style.display = 'block';
                document.getElementById('interaction').innerText = "PRESS 'E' TO DRIVE";
                nearInt = true;
            }
            if(!nearInt) document.getElementById('interaction').style.display = 'none';

            // MOVEMENT
            const speed = isDriving ? 2.0 : (keys['ShiftLeft'] ? 1.0 : 0.4);
            const rotSpeed = 0.04;

            if(keys['ArrowLeft']) camera.rotation.y += rotSpeed;
            if(keys['ArrowRight']) camera.rotation.y -= rotSpeed;
            
            // Calc Forward Vector
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0; dir.normalize();
            
            // Calc Side Vector
            const side = new THREE.Vector3();
            side.crossVectors(camera.up, dir).normalize();

            let dx = 0, dz = 0;
            if(keys['KeyW']) { dx += dir.x; dz += dir.z; }
            if(keys['KeyS']) { dx -= dir.x; dz -= dir.z; }
            if(keys['KeyA']) { dx += side.x; dz += side.z; }
            if(keys['KeyD']) { dx -= side.x; dz -= side.z; }

            const nextX = (isDriving ? car.position.x : camera.position.x) + dx * speed;
            const nextZ = (isDriving ? car.position.z : camera.position.z) + dz * speed;

            // Collision (Simple)
            let blocked = false;
            if(!isDriving && !isFlying) {
                const test = new THREE.Vector3(nextX, 2, nextZ);
                walls.forEach(w => { if(w.containsPoint(test)) blocked = true; });
            }

            if(!blocked) {
                if(isDriving) {
                    car.position.x = nextX; car.position.z = nextZ;
                    car.rotation.y = camera.rotation.y + Math.PI; // Car faces cam
                    // Cam follows car
                    camera.position.set(car.position.x - dir.x*10, car.position.y+5, car.position.z - dir.z*10);
                } else {
                    camera.position.x = nextX; camera.position.z = nextZ;
                }
            }

            // Gravity
            if(!isDriving && !isFlying) {
                camera.position.y += vy;
                vy -= 0.03;
                if(camera.position.y <= 2) { camera.position.y = 2; vy = 0; }
            } else if(isFlying) {
                 if(keys['Space']) camera.position.y += 0.5;
                 if(keys['ShiftLeft']) camera.position.y -= 0.5;
            }

            renderer.render(scene, camera);
        }

        // Run
        init();

    </script>
</body>
</html>
